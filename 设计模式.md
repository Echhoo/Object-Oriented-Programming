[TOC]



### 设计模式

概念：每个模式都描述了我们环境中反复发生的问题，然后描述了该问题解决方案的核心，这样您可以使用一百万次，而不会以同样的方式做两次。

制作公用接口。

```c++
#include<vector>
#include<list>
#include<math.h>
using namespace std;
template <class Container>
void Display_Container(Container c)
{
    Container::iterator it;
    for(it = c.begin();it!=c.end();it++){
        cout<<*t<<" ";
    }
    cout<<endl;
}
template <class Container>
void Sort(Container & c)   // sort 公共接口 stack vector map
{
    Container::iterator it1, it2;
    Container::value_type temp; 
    for (it1=c.begin(); it1!=c.end(); it1++)
    {
        for (it2=it1; it2!=c.end(); it2++) {
            if ( *it1 > *it2 ) {
                temp = *it1;
                *it1 = *it2;
                *it2 = temp;
            }
        }
    }
}
int main() {
    vector <int> v;
    list <double> l; 
    for (int i=10; i>=0; i--) {
        v.push_back(i);
        l.push_back( sin(i*3.14) ); 
    }
    Display_Container(v);
    Display_Container(l);
    Sort( v );
    Sort( l ); 
    Display_Container(v);
    Display_Container(l);
    return 0;
}
```

##### 模式描述

- 模式名称（singleton单例图）
- 问题：
  - 不是基本的数据结构，也不是整个系统的
  - 不是特定的域
- 结论：
  - 时间空间的权衡
  - 对系统灵活性，可扩展性，可移植性有影响。

##### 设计模式的作用

- 应用程序：使用设计模式减少类的依赖性，平台的依赖性。
- 工具包：使用代码重用的设计模式 如c++stl中的容器迭代器和算法
- 框架：强调设计重用、在框架中使用模式⑩学习框架的使用更容易

##### 设计模式的缺点

- 使设计复杂化
- 在空间和时间方面降低了系统的性能
- 只有需要时才使用设计模式：灵活性、可扩展性、可移植性

##### 例子：文档编辑器。（所见即所得）

设计的问题。

1. 文件结构 2. 排版 3. 装饰用户接口 3. 多种外观和标准 5. 用户操作 6. 输入检查

The document has a tree-like structure

特征：

- 子结构可能包含其他子结构（递归）

- 文字和图形统一处理

- 一个图表可以嵌入进一行文字

- 字符可以嵌入到图表中

- 单个元素和一组元素被统一处理（移动、设置字体等）。

![image-20210620210306996](C:\Users\17999\AppData\Roaming\Typora\typora-user-images\image-20210620210306996.png)

```c++
/*抽象类*/
class Glyph{  
    public:
    virtual void Draw(Window *)=0;
    virtual void Draw( Window * )=0; 
    virtual void Bounds( Rect & )=0;
    virtual bool Intersects( const Point &)=0; 
    virtual void Insert(Glyph *, int)=0; 
    virtual void Remove(Glyph *)=0; 
    virtual Glyph * Child (int)=0; 
    virtual Glyph * Parent( )=0;
}
```

### Lecture 6

#### XX1. Composite pattern复合/组合模式——对象结构型模式

（p123-132）

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621203426993.png" alt="image-20210621203426993" style="zoom:67%;" />

> **树结构**，**代替递归和类型判断**
>
> composite描述了如何使用递归组合，使得用户不必对这些类进行区别。

适用性：

- 部分-整体层次结构
- 用户忽略组合对象与单个对象的不同、统一的使用组合结构中的所有对象。

组成部分

- 通用接口（抽象类）
- 默认行为
- 访问和管理其子组件
- 访问组件的父组件

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621204156714.png" alt="image-20210621204156714" style="zoom:67%;" />

**协作**Collaborations :

- 复合对象迭代地调用叶子的操作

结果:

- 可扩展性:更容易添加新类型的组件
- 定义了类层次结构
- 简化客户代码
- 缺点:很难约束复合对象，使它们只能包含某些类型的组件。

**练习**
假设有一种编程语言只包含三种语句: 

- 赋值语句Assignment: Identifier_A = Identifier_B; 

- If语句: If (Identifier A == Identifier B) {statement1;statement2;};

- If-else语句:

  ```c++
  If (Identifier A == Identifier B)
   {statement1;statement2;...} 
  else {statement3;statement4;..｝
  ```


编写一个格式化程序，该程序以前一种语言的程序作为输入，并将其格式化为:

- 新行字符只出现在完整语句或 { 字符之后

- if或if else语句由4个字符缩进，

请参阅下面的示例代码。

```c++
A = B ;
if ( C == D ) {
	E = F ;
	if ( G == H ) {
    	tmp1 = tmp2 ;
		tmp3 = tmp4 ;
	} 
	else{
		var5 = var6 ;
	}
    A = 100 ;
}
B = 200 ;
```

要求！绘制类图！

- 在根类中应该定义什么操作

- 假设do while语句被附加到编程语言中，如何修改类图和实现

- 如何应用以下约束：if-else语句不能出现在do-while语句中？

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210620213338469.png" alt="image-20210620213338469" style="zoom:67%;" />

虚线+方框：note（注释）

**Document Formatting**

**限制定义：将字形集合拆分为行。**

- 在格式化质量和格式化速度之间进行权衡。

- 可以使用不同的算法。Lyx也是如此。

- 算法应该与数据隔离开来。
  - 算法的独立类层次结构

**Composition**:(物理元素)

最初，他包含未格式化的对象（字符、图形）。格式化算法将结构对象（行、列）插入其中

**Compositor:**（实现排版算法）

- 类中封装了不同的格式化算法
- 接口
	
	```c++
	void setCompositon(Compositon*)
	virtual void Compose()



#### 2. Strategy Pattern 策略模式——对象行为型模式

（p234-242）

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621210108740.png" alt="image-20210621210108740" style="zoom:67%;" />

适用性：

- 需要算法的不同变体
- 有些算法使用客户不应该知道的数据
- 要点：将算法与数据分离

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210620214559825.png" alt="image-20210620214559825" style="zoom:67%;" />（文档格式化// 换行算法）

Composition类负责维护和更新一个文本浏览程序中显示的文本换行。

换行策略是由抽象类conpositor的子类各自独立实现的。、

composition维护对Compositor对象的一个引用。

**结构**：

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210620215337565.png" alt="image-20210620215337565" style="zoom:67%;" />

（wrong↓）<img src="D:\Project\面向对象设计\设计模式.assets\image-20210620215428185.png" alt="image-20210620215428185" style="zoom:67%;" />



```c++
void Composition::Compose() { 
    switch ( _breakingStrategy ) {
        case SimpleStrategy:
            ComposeWithSimpleStrategy();
            break;
        case TexStrategy:
            ComposeWithTexStrategy();
            break;
            // ... 
    } 
}
// With strategy pattern 策略模式消除了case语句
void Composition::Compose() { 
    _compositor->Compose();
    // ...
}
```

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621211220108.png" alt="image-20210621211220108" style="zoom:60%;" />

#### 3. Decorator pattern 装饰器模式——对象结构型模式

（p132-139）

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621211357385.png" alt="image-20210621211357385" style="zoom:67%;" />

- Decorators装饰器为扩展功能提供了一种灵活的替代子分类的方法。

将功能扩展到的是一些**单个对象**（而不是整个类）。E.g、边框、滚动条

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210620220909900.png" alt="image-20210620220909900" style="zoom:67%;" />

1.通过 **类继承** 来增加附加功能的解决方案

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210620221051327.png" alt="image-20210620221051327" style="zoom:67%;" />

缺点: 

1. 您不能在运行时扩展或删除该功能。

2. 如果有许多装饰功能，子类的数量将会激增。

2.通过 **min class** 来增加附加功能的解决方案

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210620221505790.png" alt="image-20210620221505790" style="zoom:67%;" />

缺点：

1. 您不能在运行时扩展或删除该功能。

2. 如果有许多装饰功能，子类的数量将会激增。

3.通过 **复合类**#1 来增加98z'z'z附加功能的解决方案（没懂）

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210620221719101.png" alt="image-20210620221719101" style="zoom:67%;" />

缺点：

1. 两个类的接口不同
2. 难以递归修饰

4.通过 **复合类**#2 来增加附加功能的解决方案（没懂）

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210620221903541.png" alt="image-20210620221903541" style="zoom:67%;" />

**Decorator pattern**

- 基本类由decorator类包围

- decorator类符合基本类的接口

- 接口实现：
  - 将请求转发到基本类
  - 在转发之前或之后执行任何其他操作

- 结果：装饰器可以递归嵌套。

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210620222305457.png" alt="image-20210620222305457" style="zoom:80%;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210620222514980.png" alt="image-20210620222514980" style="zoom:80%;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210620222842157.png" alt="image-20210620222842157" style="zoom:80%;" />

**适用性** **Applicability**

- 在运行时添加或删除职责
- 组件类不必知道任何关于它的装饰者的事。

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621222220733.png" alt="image-20210621222220733" style="zoom:67%;" />

#### **decorator pattern** **和** **composite pattern**的比较：

装饰器案是退化的复合模式

意图不同

- 装饰器：用于添加额外的功能

- 复合：用于对象聚合、递归

**实施**

- 保持组件类的轻量级，否则，decorator将太重而无法使用



**例子：**

- **I / O流类**
  - 基本功能将对象转换为字节以存储到文件或内存块中。
  - 附加功能：
    - 数据压缩
    - 转化为七字节ASCII 

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210620224245131.png" alt="image-20210620224245131" style="zoom:67%;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210620224523440.png" alt="image-20210620224523440" style="zoom:67%;" />

```c++
Stream * fStream = new FileStream("test.cpp"); 
Stream * mStream = new MemoryStream(); 
Stream * fcStream = new CompressingStream( new FileStream("test.cpp") ); 
Stream * f7Stream = new ASCII7Stream ( new FileStream("test.cpp") ); 
Stream * fc7Stream = new CompressingStream( new ASCII7Stream ( new FileStream("test.cpp") )); 
fc7Stream->PutInt(12); 
fc7Stream->PutString("hello");
```

```java
import java.io.*;
import java.util.zip.*;
public class GZIPCompress {
    public static void main ( String [ ] args ) 
    throws IOException {
        BufferedReader in =
          new BufferedReader (
      	 	new FileReader( args[0] ) );
        BufferedOutputStream out =
          new BufferedOutputStream (
            new GZIPOutputStream (
              new FileOutputStream(args[1] ) ));
System.out.println("Compressing file...");
int c;
while ( (c = in.read()) != -1 )
	out.write(c);
in.close();
out.close();
System.out.println("Verifying file...");
BufferedReader in2 =
    new BufferedReader (
      new InputStreamReader (
        new GZIPInputStream (
          new FileInputStream( args[1] ) )));
String s;
while ( (s = in2.readLine()) != null )
    System.out.println(s);
    }
}
```

### Lecture 7

#### XX4. The Command Pattern 命令模式——对象行为型模式

p175-183

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621222936893.png" alt="image-20210621222936893" style="zoom:67%;" />

- 要求
  - 多个小部件可以映射到同一个操作上
  - 我们不希望实现操作的类和接口类之间的紧密耦合
  - 我们希望支持撤销Undo/重做Redo功能

**MFC解决方案**

- MFC通过**消息映射机制**解决了前两个需求

  ​	如何实现undo/redo？函数耦合解决不了问题

- 我们抽象出一个概念，这个概念可以变化形成一个类。

【向对象提出请求，但不知道被请求的操作或接收者的任何信息】

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210620225921606.png" alt="image-20210620225921606" style="zoom:67%;" />（下面三个为虚线）

**撤消**

- 还必须存储撤消信息
  - 例如，更改所选文本范围的原始字体
  - 例如，删除所选对象所有对象的信息都应存储

- 不可撤销
  - 没有意义的命令不应该被撤消
  - 命令是否无意义应该在**运行**时确定
  - Add  Command::Reversible

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210620230557839.png" alt="image-20210620230557839" style="zoom:67%;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210620230638088.png" alt="image-20210620230638088" style="zoom:67%;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210620230624930.png" alt="image-20210620230624930" style="zoom:67%;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210620230655303.png" alt="image-20210620230655303" style="zoom:60%;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210620230717433.png" alt="image-20210620230717433" style="zoom:67%;" />

**适用性**

- 支持撤消

- 支持上下文敏感的菜单

- 支持命令宏

- 支持进行日志记录更改以恢复一个崩溃的系统

- 支持信息系统中交易的概念

**命令模式的结构**（专门构建一个类去执行操作，然后记录操作，为了实现撤销功能重做功能）

Invoke应该是抽象接口，它包含一个command类，这样的话用户就不需要手动去操作command类，调用我们提供给他的invoke方法，然后就会自动执行命令

**结构**

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621224416449.png" alt="image-20210621224416449" style="zoom:67%;" />



### Lecture 8

#### 5. Abstract Factory Pattern 抽象工厂模式——对象创建型模式

p66-74

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621225233075.png" alt="image-20210621225233075" style="zoom:67%;" />

一些应用程序需要在运行时更改其接口样式

- 第一步
  - 抽象控件类
  - 具体的子类

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210620232438299.png" alt="image-20210620232438299" style="zoom:67%;" />

```c++
//Create objects directly
// 直接创建子类
switch (Style) { 
    case Motif: 
        ScrollBar * sb = new MotifScrollBar; 
        Button * bn = new MotifButton; 
        Menu * mn = new MotifMenu;
        break; 
    case Mac:
        ScrollBar * sb = new MacScrollBar;
        Button * bn = new MacButton; 
        Menu * mn = new MacMenu; 
        break;
    case PM:
        ScrollBar * sb = new PMScrollBar;
        Button * bn = new PMButton;
        Menu * mn = new PMMenu; 
        break;
}
```

缺点：

- 冗长：每次我们创建一些小部件时，都必须使用switch语句
- 可能会导致问题：您创建了一个Mac风格的按钮，但当前的样式是Motif
- 很难切换样式：如何跟踪旧的小部件来销毁它们？（难动态切换）

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210620232902309.png" alt="image-20210620232902309" style="zoom:67%;" />

```c++
// 直接通过工厂类创建子类
switch (Style) { 
    case Motif:
        guiFactory = new MotifFactory( ); 
        break;
    case Mac: 
        guiFactory = new MacFactory( ); 
        break;
    case PM: 
        guiFactory = new PMFactory( );
        break; 
}
ScrollBar * sb = guiFactory->CreateScrollBar( ); 
Button * bn = guiFactory->CreateButton( ); 
Menu * mn = guiFactory->CreateMenu( );
```

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210620233528066.png" alt="image-20210620233528066" style="zoom:67%;" />

**实施**

工厂：作为单例

- 定义可扩展工厂
  - 假设我们希望将小部件“listbox”附加到上一个工厂
  - 解决方案1：更改工厂类的接口。
  - 解决方案2：定义单个操作“make”以生产所有产品。

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210620233941142.png" alt="image-20210620233941142" style="zoom:67%;" />

​										：使工厂类可扩展——>make(name:type):Widget*

```c++
// To append a new type of widget
// 增加一种新类型的小部件

Widget * MotifFactory::Make(string name)
{
    if(name =="ScrollBar")return new MotifScrollBar();
    //other widgets...
    //to append new
    if(name =="ListBox") return new MotifListBx();
}
//..
ScrollBar * sb= dynamic_cast<ScrollBar*>(guiFactory->Make("ScrollBar"));
ListBox * lb  = dynamic_Cast<ListBox*>(guiFactory->Make("ListBox"));
```



#### 6. Iterator pattern  迭代器模式 （没懂）——对象行为型模式

(p193-205)

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621231517835.png" alt="image-20210621231517835" style="zoom:67%;" />

#### （& visitor  pattern 访问者模式）

- 拼写检查和单词截断（换行时）
  - 我们只对文件的文本感兴趣
  - 文本分散在整个层次结构中
  - 不同类型的字形glyph可以将其子级存储在不同的数据结构中（数组、链表等）
  - 可能有许多可能的文本分析需求。

通过迭代器访问这些信息：

- 对于glyph类，我们不想更改它来适应遍历/分析功能

- 我们需要不同类型的遍历

  前序，后序，中序等

  例如：列表：列表迭代器，列表反转器
  
  <img src="D:\Project\面向对象设计\设计模式.assets\image-20210621232300885.png" alt="image-20210621232300885" style="zoom:67%;" />

```c++
// 迭代器实现
template<class Item>
    class List{ //类模板
        List(long size=DEFAULT_LIST_CAPACITY);
        long count() const;
        Item & Get(long index)const;
        void print();
    }
template <class Item>
    class Iterator{
      public:
        virtual void First()=0;
        virtual void Next() = 0; 
        virtual bool IsDone() const=0;
        virtual Item CurrentItem() const = 0;
      protected: 
        Iterator();
    }
```

```c++
template <class Item> 
    class ListIterator: public Iterator<Item> {
        public:
        ListIterator (const List<Item> * aList): _list(aList), _current (0) { };
        virtual void First() { _current = 0; }
        virtual void Next() { _current ++; }
        virtual bool IsDone() const {
            return _current >= _list->Count(); 
        }
        virtual Item CurrentItem() const {
            if (IsDone () )
                throw IteratorOutOfBounds; 
            return _list->Get( _current );
        }
      private: 
        const List<Item> * _list; 
        long _current; 
    }
void PrintEmployees(ListIterator<Employee*>&i) {
    for (i.First(); !i.IsDone(); i.Next() ) {
        i.CurrentItem()->Print();
    }
}
List<Employee*> * employees;
ListIterator<Employee*> forward( employees );
ReverseListIterator<Employee*> backward( employees); 
PrintEmployees( forward ); 
PrintEmployees( backward );
```

**容器和迭代器是紧密耦合的**

```c++ 
void PrintEmployees(ListIterator<Employee*>& i)
```

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621010027910.png" alt="image-20210621010027910" style="zoom:67%;" />

**独立的迭代器**

```c++
void PrintEmployees(ListIterator<Employee*>& i) 
void PrintEmployees(SkipListIterator<Employee*>& i)
```

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621010249964.png" alt="image-20210621010249964" style="zoom:67%;" />

**具有共同祖先的迭代器**

```c++
void PrintEmployees(Iterator<Employee*>& i)
```

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621010331466.png" alt="image-20210621010331466" style="zoom:67%;" />

Lists**也有共同的祖先**

编写同时适用于List和SkipList的代码

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621010454954.png" alt="image-20210621010454954" style="zoom:67%;" />

假设我们希望只有当列表中不包含任何与该项相同的项时，才能将该项插入到列表中

```c++
// 伪代码
void ConditionalInsert(AbstractList *list,Item I)
{
    //Create an iterator it for the list; //how to do
   // Iterator * it = list->CreateIterator();
    for ( it->First(); ! it->IsDone; it->Next() ) 
        if ( it->CurrentItem == I ) break;
    if ( ! it->IsDone )
        return ; // the item already exist. 
    list->Append( I );
}
```

**CreateIterator（）**：应用多态机制。

- 优点：界面更简洁；更大的重复使用代码的机会。

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621010944315.png" alt="image-20210621010944315" style="zoom:67%;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621012645166.png" alt="image-20210621012645166" style="zoom:67%;" />

​								(迭代器模式的一般结构)

实现：**确保迭代器被删除** （未删除造成内存泄漏）

使用**Proxy pattern代理模式**来解决问题

#### 7. Proxy Pattern 代理模式——对象结构型模式

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210622001246497.png" alt="image-20210622001246497" style="zoom:67%;" />

（p155-164）

对一个对象进行访问控制的一个原因只有在我们确实需要这个对象时才对它进行创建和初始化。

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210622001732862.png" alt="image-20210622001732862" style="zoom:67%;" />

- 将每个指针封装到一个对象中

- 在对象中，重载->和*操作符

- 将对象声明为堆栈变量

- 当对象超出作用域时，其析构函数将删除指针

  （创建类，在函数内声明了局部变量。所以会自己析构了）

```c++
template <class Item> 
    class IteratorPtr {   // 指针类代理
      public:
        IteratorPtr( Iterator<Item> * i) : _i(i) {} 
        ~IteratorPtr() { delete _i; }
        Iterator<Item>* operator->() { return _i; }  //重载*
        Iterator<Item>& operator*() { return * _i; }  // 重载&（->）
      private: 
        // to avoid multiple deletions of _i 
        // 避免多次删除 _i
        IteratorPtr(const IteratorPtr & );
        IteratorPtr& operator=(const IteratorPtr&);
      private:
        Iterator<Item>* _i;
    }

// pseudo-code
void ConditionalInsert(AbstractList * list, Item I) { 
    IteratorPtr it( list->CreateIterator() );
    // syntax of using an IteratorPtr object is as the 
    // same as the Iterator*
    // 使用迭代器Ptr对象的语法与迭代器*相同
    for ( it->First(); ! it->IsDone; it->Next() )
        if ( it->CurrentItem == I ) break;
    if ( ! it->IsDone ) 
        return ; // the item already exist. 
    list->Append( I ); 
    // the "Iterator*" will be deleted automatically 
}
```

**健壮的迭代器**

一般来说，在遍历聚合对象时修改它是危险的。

第一个问题：在插入前插入点之后的元素会向后移动

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621012755919.png" alt="image-20210621012755919" style="zoom:50%;" />

第二个问题：:插入操作可能导致重新分配内存

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621013030348.png" alt="image-20210621013030348" style="zoom: 67%;" />

**Solution for robust iterator**

创建迭代器时，将其注册到聚合中。在插入和删除时，聚合将调整迭代器的内部状态。

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621013235044.png" alt="image-20210621013235044" style="zoom:67%;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621013415354.png" alt="image-20210621013415354" style="zoom:67%;" />

-在某些环境，一定要用迭代器进行遍历。把结构的访问委托给迭代器，迭代器的职能分的比较清楚。

**Traversing a Glyph element**遍历一个字形元素

```c++
void func( Glyph * g) 

{
    Iterator<Glyph*> *it = g->CreateIterator();
    // the Proxy pattern can be used here instead. 
    // 这里也可以使用代理模式
    for (it->First(); ! it->IsDone(); it->Next() ) {
        Glyph * child = it->CurrentItem();
        // do something with current child
    }
    delete it;
}
```

**PreorderIterator: Traversing a Glyph hierarchy tree in preorder**

前序遍历，遍历glyph层次结构树

- The “first” operation of a preorder iterator 第一个操作

```c++
void PreorderIterator::First() { // 指向第一个元素
    Iterator<Glyph*> * i = _root->CreateIterator();  //i为根
    if (i) {
        i->First();
        _iterators.RemoveAll();
        _iterators.Push(i);（放入i）
    }
}
```

- The next( ) operation of a pre-order iterator  下一个操作

  - 使用堆栈记录先前到达的路径：堆栈的每个元素都是迭代器；迭代器指向的CurrentItems

  形成了路径

  - 如果当前项不是叶节点，只需让迭代器指向它最左边的子项即可

  - 如果遇到叶节点，我们将调用Top（）->Next（）

  - 如果已经搜索了top的所有子级，请删除top，然后调用Top（）->Next（）。

  ```c++
  void PreorderIterator::Next() {
      Iterator<Glyph*> * i =
          _iterators.Top()->CurrentItem()-> 
          CreateIterator();
      i->First();
      _iterators.Push(i);
      while { _iterators.Size() > 0 && _iterators.Top()->IsDone() ) //?????
      { 
          delete _iterators.Pop();
          _iterators.Top()->Next(); 
      }
  }
  ```

  <img src="D:\Project\面向对象设计\设计模式.assets\image-20210621015041695.png" alt="image-20210621015041695" style="zoom:50%;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621015053303.png" alt="image-20210621015053303" style="zoom:50%;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621015210897.png" alt="image-20210621015210897" style="zoom:50%;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621015255969.png" alt="image-20210621015255969" style="zoom:50%;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621015333401.png" alt="image-20210621015333401" style="zoom:50%;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621015448366.png" alt="image-20210621015448366" style="zoom:50%;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621015510398.png" alt="image-20210621015510398" style="zoom:50%;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621015528513.png" alt="image-20210621015528513" style="zoom:50%;" />

#### 8. Visitor pattern 访问者模式——对象行为型模式

（p246-256）

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210622002605858.png" alt="image-20210622002605858" style="zoom:67%;" />

**遍历与遍历操作**

- 在哪里放置遍历操作，例如拼写检查、断字
  - 将分析器集成到迭代器中====》可能有很多分析器
  - 用迭代器分离分析器

- 不同的分析器对不同类型的聚合对象感兴趣，例如拼写检查器只处理字符

  ===》如何判断聚合的类型

**第一步:封装分析器**

- 在迭代过程中，每当我们遇到一个新的字形，我们就把它输入分析器

  （遇到新字形，主动将字形feed给分析器analyzer）

- 分析器可以积累信息(在本例中是字符)。

1. 直接解决方法：使用 type-casting

```c++
SpellingChecker spellingChecker; 
Composition *c; 
Glyph * g; 
PreorderIterator i(c);
for ( i.First(); ! i.IsDone(); i.Next() ) 
{
    g = i.CurrentItem( );
    SpellingChecker.Check( g );  // 把新字形输入分析器
}
void SpellingChecker::Check( Glyph * glyph ) {
    Character * c;
    Row * r; 
    Image * i;
    if (c=dynamic_cast<Character*> (glyph)) { 
        // analyze the character 
    }else if (r=dynamic_cast<Row*> (glyph ) { 
        // prepare to analyze r's children 
    }else if (i=dynamic_cast<Image*>(glyph ) {
        // do nothing 
    }
}
```

**（两次分发原则）？？**

安全的解决方案：使用特殊操作

- Add the operation：增加操作，引入新抽象到Glyph类。checker即访问者visit

```c++
void CheckMe(SpellingChecker &checker)
```

- 对于Glyph中的每个子类，定义操作

```c++
void Subclass::CheckMe(SpellingChecker& checker) { 
    checker.Check(this);  // 被访问者主动送
}
```

```c++
class SpellingChecker { 
  public:
    SpellingChecker(); 
    void Check(Character*);
    void Check(Row*);
    void Check(Image*);
  private: 
    char _currentWord[ MAX_WORD_SIZE ];
}

SpellingChecker spellingChecker; 
Composition *c; 
Glyph * g; 
PreorderIterator i(c);
for ( i.First(); ! i.IsDone(); i.Next() ) {
    g = i.CurrentItem( ); 
    // SpellingChecker.Check( g );  // 把新字形输入分析器check
    g.CheckMe( spellingChecker );// g对象自己调用处理器，
}
```

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621021620497.png" alt="image-20210621021620497" style="zoom:67%;" />

visitor模式的好处？？主要用在？？02112

### Lecture 10

#### XX9.  The builder pattern 生成器模式 1-----9都未参照课本

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210622004646042.png" alt="image-20210622004646042" style="zoom:67%;" />

问题:

- 将RTF文档转换为纯文本，TeX和TextWidget格式。

  <img src="D:\Project\面向对象设计\设计模式.assets\image-20210621022020665.png" alt="image-20210621022020665" style="zoom:50%;" />

源文件格式如下：

```rtf
{\rtf1\ansi\ansicpg936\deff0\deflang1033\deflangfe2052
{\fonttbl{\f0\fmodern\fprq6\fcharset134\'cb\'ce\'cc\'e5;}
 {\f1\fswiss\fprq2\fcharset0 Arial;}
}\viewkind4\uc1\pard\lang2052\f0\fs20
This is a line in SongTi, 10 points.\par
\par
\f1\fs28 Here is another line in Arial, 14
points.\f0\fs20\par
}
```

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621022249737.png" alt="image-20210621022249737" style="zoom:67%;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621022328632.png" alt="image-20210621022328632" style="zoom:50%;" />

**解决方案的特点**

- 将转换器与读取器分离

- 隐藏创建和组装复杂对象的详细信息
- 算法的重用

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621022957857.png" alt="image-20210621022957857" style="zoom:67%;" />

**参与者**

- Builder（开发者）
  - 指定抽象接口

- 具体Builder
  - 可能通过与其他对象交互来构造和组装部件 buildPart()
  - 检索产品 GetResult

- 总监(Director)
  - 调用构造器builder来构造产品

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621023412156.png" alt="image-20210621023412156" style="zoom:67%;" />

​															[顺序图]

**结果**

- 建设者(Builder) 隐藏了产品的内部结构和装配细节，从而使得结构模块化与代码重用

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621024013869.png" alt="image-20210621024013869" style="zoom:67%;" />

**实现**

- builder接口必须是通用的
- 有时我们可能需要访问早期构建的部分产品

**Builder模式与抽象工厂模式的比较**

- Build pattern建造者模式

  a. 构建器类（builder class）负责组装产品，可能通过调用其他类。(不但负责生产，也负责组装) 

  b. 构建器类（builder class）一步一步地制造和组装产品。

- Abstract factory pattern 抽象的工厂模式

  a. 抽象工厂模式的客户端client负责组装产品。

  b. 工厂类factory class一次性生产所有的零件。

#### 10.  The factory method pattern 工厂方法模式-对象创建型模式

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621100138704.png" alt="image-20210621100138704" style="zoom:67%;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621100244273.png" alt="image-20210621100244273" style="zoom:67%;" />

- 多文档框架
  - 打开多个文档
  - 活动文档窗口：平铺，层叠
  - 全部关闭

主要类：application和document两个抽象类，客户通过子类实现具体的功能。application负责管理document并根据需要创建他们（如new，open）

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621100804940.png" alt="image-20210621100804940" style="zoom:67%;" />

​										（问题：框架必须实例化类、但他只知道不能被实例化的抽象类）

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621101211794.png" alt="image-20210621101211794" style="zoom:67%;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621101313641.png" alt="image-20210621101313641" style="zoom:67%;" />

​		**适用性**

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621101424570.png" alt="image-20210621101424570" style="zoom:67%;" />

​		**结构**

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621101913789.png" alt="image-20210621101913789" style="zoom:67%;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621102148594.png" alt="image-20210621102148594" style="zoom:67%;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621102521514.png" alt="image-20210621102521514" style="zoom:67%;" />

**工厂模式的另一种效果：连接并行类层次结构** **Connect parallel class hierarchy**

举个例子：图表编辑器

​	图表元素的操作：

​	- 伸展

​	- 移动

​	- 调整大小

​	- 旋转

**问题分析**

- 交互的实现是复杂的

- 在操作过程中，应存储和更新一些信息，例如元素的角度
- 不同元素的行为不同，例如调整一行和一行文本的大小

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621103228643.png" alt="image-20210621103228643" style="zoom:67%;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621103556901.png" alt="image-20210621103556901" style="zoom:67%;" />

**例子**:统一图形编辑程序

模板可以用于避免creator类的子类

```c++
class Creator{
    public:
    vitrual Product * Create(ProductID);
};
Product *Create::Create (ProductID id){
    if (id==MINE) return new Myproduct;
    if (id ==YOURS) return new YOURProduct;
    ...
}

class MyCreator:public Creator{
    virtual Product *Create(ProductID id0){
        if (id==MINE) return new Myproduct;
        if (id ==YOURS) return new YOURProduct;
        ...
        return Creator::Create(id);// mycreator 扩建了所创建产品的种类,讲除少数不同子产品以外的创建职责延迟给了父类
    }
}
```

**使用模板以避免创建子类,提供creator的模板子类.**

```c++
class Creator {
public:
	virtual Product * CreateProduct() = 0;
};
template <class TheProduct>
class StandardCreator: public Creator{ //类模板
public:
 	virtual Product* CreateProduct() {
    	return new TheProduct;
    }
}
StandardCreator<ProductA> aCreator;
StandardCreator<ProductB> bCreator;
// 使用这个模板 客户仅提供产品类\而不需要创建creator的子类
```




#### X11.  The prototype pattern 原型模式 一一对象创建模式

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621105152957.png" alt="image-20210621105152957" style="zoom:67%;" />

- 从头构造一个对象是非常昂贵的。
- 想要一个对象，它是一个现有对象的副本。

乐谱编辑

- 自定义通用框架

- 有用于添加新图形对象的工具
- 有一些操作图形对象的工具

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621105816882.png" alt="image-20210621105816882" style="zoom:67%;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621105959655.png" alt="image-20210621105959655" style="zoom:67%;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621110220200.png" alt="image-20210621110220200" style="zoom:67%;" />

​				（让GraphicTool通过拷贝或者克隆一个Graphic的子类的实例来创建新的。实例就是一个原型）

​					拷贝之后加入乐谱中

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621110721233.png" alt="image-20210621110721233" style="zoom:67%;" />

​				**结构**：

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621110909528.png" alt="image-20210621110909528" style="zoom:67%;" />

**优点：**

- 运行时增加和删除产品
- 改变值指定新对象
- 改变结构以指定新对象
- 减少子类的构造
- 用类动态配置应用

缺陷：每一个prototype的子类都必须实现clone操作

**实现：**

- 用一个原型管理器prototype manager注册，客户可以在注册表中浏览和储存销毁一个原型prototype

- 实现克隆操作
  - 浅拷贝：拷贝的对象和原来的对象共享指向内存的指针
  - 深拷贝：复制对象和元对象相互独立。

### Lecture 11

#### 12. Adaptor pattern 适配器模式——类对象结构性模式

一个适配器:一种设备，它连接了那些原本没有被设计成连接的设备

也就是转接器

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621112127841.png" alt="image-20210621112127841" style="zoom:67%;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621112155006.png" alt="image-20210621112155006" style="zoom:67%;" />

**例子**：绘图编辑器

- 几何图像易于实现

- 文本形状很难实现

  displaying

  Editing

- 我们想重用现有的TextView类，我们不能或不希望改变TextView的接口

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621113400237.png" alt="image-20210621113400237" style="zoom:67%;" />

adapter除了将接口进行匹配之外，害负责提供被匹配的类所没有提供的功能，如（Manipulator拖动）

**适用性**：

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621113814460.png" alt="image-20210621113814460" style="zoom:67%;" />

**结构**：

1. 多重继承（类适配器）

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621114032269.png" alt="image-20210621114032269" style="zoom:67%;" />

2. 对象组合(对象适配器)

   <img src="D:\Project\面向对象设计\设计模式.assets\image-20210621114148468.png" alt="image-20210621114148468" style="zoom:67%;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621114741317.png" alt="image-20210621114741317" style="zoom:67%;" />

**样例代码**

- 多重继承方案
  - 公开继承接口interface
  - 私下privately inheritance继承实现implementation

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621113400237.png" alt="image-20210621113400237" style="zoom:67%;" />

```c++
class Shape{ // 基类
public:
    Shape();
    virtual void BoundingBox{
        Point & bottomLeft,Point &topRight;
    }const;
    virtual Manipulator * CreateManipulator()const;
}

class TextView{
public:
   TextView();
   void GetOrigin(Coord&x, Coord&y) const;
   void GetExtent(Corrd &wAAZAidth, Coord&height) const;
   virtual bool IsEmpty() const; 
}
// 用公共方式继承接口，用私有方式继承接口的实现。
class TextShape : public Shape,private TextView{ //private:被自身使用不被外界使用
public:
    //boundingbox对TextView的接口进行转换使之匹配Shape
    virtual void BoundingBox{
        Point & bottomLeft,Point &topRight;
    }const{
        Coord bottom，left，width，height;
        GetOrigin(bottom,left);
		GetExtent(width,height);
        bottomLeft = Point(bottom, left);
        topRight = Point(bottom + height, left + width);
    }
    virtual bool IsEmpty() const{
        return TextView::IsEnpty();//直接转发请求
    }
    virtual Manipulator * CreateManipulator()const{
        return new TextManipulator(this);
    }
}
```

**结果**

适配器adaptor应该附加adaptee （被适配者）没有的，但是是必须的功能。

**实现**

- 可插拔适配器
  - 能够适应不同接口的适配器。

##### Lambda表达式

一个lambda表达式表达式本质上是一个匿名函子，c++11允许使用。

```c++
vector<string>lines;
sort(lines.begin(),lines.end()),
[](string s1, string s2) -> bool { 
	return s1.size() > s2.size( ); 
 } 
);
```

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621132939386.png" alt="image-20210621132939386" style="zoom:67%;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621133315198.png" alt="image-20210621133315198" style="zoom: 67%;" />

**STL是一个类模版，表示一个函子。**

```c++
void print_num(int i){...} 
struct PrintNum { 
    void operator()(int i) const {
        std::cout << i << '\n';
    }
};
int main() {
    std::function<void(int)> f1 = print_num;
    std::function<void()> f2 = [ ]( ) { print_num(42); };
    std::function<void(int)> f3 = PrintNum();
}
```

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621133734825.png" alt="image-20210621133734825" style="zoom:67%;" />

```c++
 #include <iostream>
 #include <functional>
 //Adaptee 1
 struct CoffeMaker {
 	void Brew (double quantity, double temp) const {
         std::cout << "I am brewing " << quantity <<"ml coffee @" << temp
         <<" degree C" <<std::endl; 
	}
 };
 //Adaptee 2 (having difference interface from Adaptee 2)
 struct JuiceMaker{
 	void Squeeze (double quantity) const {
     	std::cout << "I am making " << quantity <<"ml Juice" <<std::end
     }
 };
 // Target
 struct Beverage{
	 virtual void getBeverage (int quantity) = 0; // 接口
 };
```
```c++
 // Adapter
 class Adapter : public Beverage {
 	std::function<void(int)> Request; // 函子
 public:
	 Adapter(CoffeMaker *cm1){ // 构造函数
     	Request = [cm1](int quantity) { // 构建lambda表达式但未执行
        	cm1->Brew(quantity,80);
        };
 	}
     Adapter(JuiceMaker *jm1){
         Request = [jm1](int quantity){
        	 jm1->Squeeze(quantity);
         };
     }
     void getBeverage(int quantity){ // 实现父类函数
     	Request(quantity); // 调用函子 request 这里不太懂
     }
 };
```
```c++
// client 
int main(){
    CoffeeMaker coffeMaker;
    Adapter adp1 ( & coffeMaker);
 	adp1.getBeverage(30);
    //
 	JuiceMaker juiceMaker
 	Adapter adp2 ( & juiceMaker );
 	adp2.getBeverage(40);
}
```

#### XX13. Bridge pattern 桥接模式

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621135115233.png" alt="image-20210621135115233" style="zoom:67%;" />

- 动机
  - 当一个抽象类有几个可能的实现，通常我们使用继承。当抽象与实现部分固定在一起，很难对抽象部分和实现部分独立的进行修改、扩充和复用。

- 一个例子
  - 一个可移植的X和PM Windows抽象部分的实现
  - 使用继承的缺点
    - 太多类
    - 使客户端依赖于平台。我们可以在这里使用抽象工厂模式。<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621135540365.png" alt="image-20210621135540365" style="zoom:67%;" />

**桥接模式**

- 有两个因素:窗口种类和窗口实现window kinds and window implementation

- 我们使用两个独立的类层次

  \- 一个层次建模不同种类的窗口

  \- 另一个层次建模窗口的详细实现。

  \- 我们需要为所有可能的操作找到一个狭窄的接口。

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621140505199.png" alt="image-20210621140505199" style="zoom:67%;" />

**适用性**：

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621140834114.png" alt="image-20210621140834114" style="zoom:67%;" />

**结构**：

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621141027579.png" alt="image-20210621141027579" style="zoom:67%;" />

**关于桥接模式的讨论**

- 抽象层次结构和实现层次结构都可以通过子类化进行扩展

- 改变实现类不会影响抽象类(不需要重新编译)

- 细节对用户透明

#### **桥接模式和策略模式Strategy pattern的区别**

  - 策略模式：对于一个操作，运行时开关具有上下文，它是一个行为模式a behavoural pattern
  - 桥接模式：类层次结构，它是一种结构模式 a structural pattern



### Lecture12

#### XX14. Facade Pattern 外观模式——对象结构型模式

（p139-146）

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621141909189.png" alt="image-20210621141909189" style="zoom:67%;" />

- 大多数用户希望子系统有一个简化的界面（模块功能多，对新手不友好，将常用的类和功能封装出来）。而其他用户（高级用户）希望直接访问子系统的所有组件。

  <img src="D:\Project\面向对象设计\设计模式.assets\image-20210621145322089.png" alt="image-20210621145322089" style="zoom:67%;" />

- 例如：一个编译器系统（普通用户就只要编译就行了，高级用户要去到底层进行修改) 

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621150528892.png" alt="image-20210621150528892" style="zoom:67%;" />

**适用性**：（松耦合关系）

- 当应用大多数模式时，会产生更多更小的类。这使得子系统更易于重用和自定义，但是对于不需要自定义的客户端来说，使用它也变得更加困难====》facade可以提供一个简单的默认接口
- 提高子系统的独立性和可移植性

**结构**

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621150626815.png" alt="image-20210621150626815" style="zoom:67%;" />



#### 15. Chain of Responsibility 职责链模式——对象行为型模式

（p167-175）

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621150758863.png" alt="image-20210621150758863" style="zoom:67%;" />

- 动机
  - 上下文相关帮助
  - 具体帮助 -> 一般帮助 ->更一般的帮助
  - 发送者不清楚谁将响应请求

- 解决方案说明

  链式调用，逐级上层转发

  <img src="D:\Project\面向对象设计\设计模式.assets\image-20210621151046018.png" alt="image-20210621151046018" style="zoom:67%;" />

  <img src="D:\Project\面向对象设计\设计模式.assets\image-20210621151211622.png" alt="image-20210621151211622" style="zoom:67%;" />

  要沿着链转发请求，并保证接收者为隐式的，每个在链上的对象都有一致的处理请求和访问连上后继者的接口，定义带有handlehelp操作的HelpHandler类，是所有候选对象类的父类，或者被定义为一个混入的minix类。

  <img src="D:\Project\面向对象设计\设计模式.assets\image-20210621151645072.png" alt="image-20210621151645072" style="zoom:67%;" />

**适用性：**

  <img src="D:\Project\面向对象设计\设计模式.assets\image-20210621151910044.png" alt="image-20210621151910044" style="zoom:67%;" />

**结构：**

  <img src="D:\Project\面向对象设计\设计模式.assets\image-20210621151948674.png" alt="image-20210621151948674" style="zoom:80%;" />

**效果**：

  - 减少耦合度
      - 发送者只知道它的请求会得到适当的处理
- 增强了给对象指派职责的灵活性（动态更改）
- 不保证被接受

**实现**

1. 实现后继者链

   - 定义新的连接
   - 使用已有的链接
     - 复合模式composite pattern 中的父指针

2. 链接后继者

3. 表示请求

   - 只是一种请求// 直接调用一个操作

   - 使用一个处理函数，函数以请求吗（request code整数或字符串）为参数

     - 参数必须被打包和解包

   - 请求对象：使用独立的请求对象来封装请求参数。Request类描述请求，新类型的请求由子类定义。

     Request可定义一个访问器accessor函数以返回该类的标识符。

     ```c++
     //说明请求对象使用的代码段
     //code segment to illustrate the use of request objects
     void Handler::handleRequest () (Request* theRequest){
         switch(theRequest->GetKind()){ // 定义于基类Request的GetKind()识别请求的类型
             case Help:
                // cast argument to appropriate type
                 handleHelp( (HelpRequest * ) theRequest );
                 break;
             case Keyboard_Message: 
                 handlePrint( (Keyboard_Message *) theRequest );
                 break;  
             default: 
                 // ...
                 break; 
         } 
     }
     ```

     代码示例：

     ```c++
     typedef int Topic;
     const Topic NO_HELP_TOPIC = -1
     
     class HelpHandler { // 基类
     public:
         HelpHandler ( HelpHandler* successor = 0, // successor链表指向
                      Topic= NO_HELP_TOPIC );
         virtual bool hasHelp( );
         virtual void setHandler( 
         	HelpHandler * successor, Topic );
         virtual void handleHelp( );
     
     private: 
         HelpHandler * _successor;
         Topic _topic; 
     };
     
     HelpHandler::HelpHandler (HelpHandler *successor , Topic t):
          _successor(successor), _topic(t) { }
     bool HelpHandler::hasHelp() { 
         return _topic != NO_HELP_TOPIC;   
     }
     void HelpHandler::handleHelp() {
         if ( _successor != 0 ) {
             _successor->handleHelp();
         }
     }
     ```
	  Widget抽象类的子类包括所有窗口组件。是HelpHandler的子类

     ```c++
     class Widget: public HelpHandler {
     protected: 
         Widget( Widget * parent_, Topic t = NO_HELP_TOPIC );
     private:  
         Widget* parent; 
     };
     
     Widget::Widget ( Widget * parent_, Topic t) :HelpHandler( parent_, t ) { 
         parent = parent_; 
     }
     ```
     button类是Widget的子类。button两个参数：对包含他的窗口组件的引用和自身的帮助主题。
     
     ```c++
     class Button: public Widget {
     public: 
         Button (Widget* parent_, Topic t= NO_HELP_TOPIC );
     
         virtual void handleHelp();
     }
     Button::Button(Widget * parent_, Topic t) :Widget (parent_, t ) { }
     void Button::handleHelp() {
         if ( hasHelp() ) {
             // Offer help on the button
         } else {
             HelpHandler::handleHelp();
         }
     }
     
     //dialog类似button，但是后继者是application的一个实例
     class Dialog: public Widget {
     public: 
         Dialog( HelpHandler * parent_, Topic t = NO_HELP_TOPIC );
     	virtual void handleHelp();
     }
     Dialog::Dialog (HelpHandler* parent_, Topic t):Widget(0) {
         setHandler( parent_, t );
     }
     void Dialog::handleHelp() {
         if ( hasHelp() ) {
             // offer help on the dialog
         } else {
             HelpHandler::HandleHelp();
         }
     }
     ```
      <img src="D:\Project\面向对象设计\设计模式.assets\image-20210621161442255.png" alt="image-20210621161442255" style="zoom:67%;" />

     ```c++
     class Application: public HelpHandler {
     public: 
         Application(Topic t): HelpHandler(0,t) {}
         virtual void handleHelp();
      }
      void Application::handleHelp() {
       // application-specific operations, eg.
       // show a list of help topics
      }
      
     const Topic APPLICATION_TOPIC = 1;
     const Topic PRINT_TOPIC =2;
     const Topic PAPER_ORIENTATION_TOPIC =3 ;
     Application* application = 
         new Application(APPLICATION_TOPIC);
     Dialog * dialog = 
         new Dialog ( application, PRINT_TOPIC);
     Button * button = 
         new Button( dialog, PAPER_ORIENTATION_TOPIC );
     button->HandleHelp();



#### 16. Interpret pattern 解释器模式——类行为型模式

（p183-193）

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621162044152.png" alt="image-20210621162044152" style="zoom:67%;" />

- 为简单语言定义语法。
- 在语言中表示句子，解释句子。
- 常常会使用composite pattern，但是 interpreter pattern更注重的是**如何处理 被表示的language**

- 通常需要对象树上的递归操作。//？

**例子**

- 一个文法定义正则表达式

  <img src="D:\Project\面向对象设计\设计模式.assets\image-20210621163134650.png" alt="image-20210621163134650" style="zoom:80%;" />

  <img src="D:\Project\面向对象设计\设计模式.assets\image-20210621163418839.png" alt="image-20210621163418839" style="zoom:67%;" />

  抽象语法树：

  <img src="D:\Project\面向对象设计\设计模式.assets\image-20210621163506310.png" alt="image-20210621163506310" style="zoom:67%;" />

  如果我们为BooleanExp的**每一个子类都定义解释（Interpret）操作**，那么就得到了这些正则表达式的一个解释器。

**适用性：**

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621163731957.png" alt="image-20210621163731957" style="zoom:67%;" />

**结构：**

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621163857673.png" alt="image-20210621163857673" style="zoom:67%;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621163931200.png" alt="image-20210621163931200" style="zoom:67%;" />

**实现：**

```c++
class BooleanExp{
public:
    virtual ~BooleanExp();
    virtual bool Evaluate(Context &) = 0; // 接口  评估求值
    virtual BooleanExp * Replace( const char*, BooleanExp & ) = 0; // 替换
    virtual BooleanExp * Copy() const = 0; // 拷贝
}

class Context{
public:
    bool Lookup(const char*) const;   // 上下文查找
    void Assign(VariableExp *, bool);  // 赋值
}

class VariableExp: public BooleanExp { 
public:
    VarialeExp( const char * name) { _name = strdup(name); }
    virtual ~VariableExp(); 
    virtual bool Evaluate( Context & aContext) { 
        return aContext.Lookup( _name ); // 变量直接通过上下文查找
    }
    virtual BooleanExp * Replace( const char* name, BooleanExp & exp) { 
        if (strcmp(name, _name) == 0 )
            return exp.Copy();//有就复制
        else
            return new VariableExp(_name); // 没有就新建
    }
    virtual BooleanExp * Copy() const {
        return new VariableExp(_name);  // 创建新的对象
    }
    private: 
    char * _name;
}

class AndExp: public BooleanExp { 
public:
    AndExp(BooleanExp* op1, Boolean* op2) {
        _operand1 = op1; _operand2 = op2;
    }
    virtual ~AndExp(); 
    virtual bool Evaluate( Context & aContext) {
        return _operand1->Evaluate(aContext) &&  // 递归实现evalute
            _operand2->Evaluate(aContext);
    }
    virtual BooleanExp * Replace( const char* name, 
                                 BooleanExp & exp) { // 递归实现，变量分别替代 
        return new AndExp(
            _operand1->Replace(name,exp), 
            _operand2->Replace(name,exp) ) 
    }
    virtual BooleanExp * Copy( ) const {  // 创建新对象
        return new AndExp( _operand1->Copy(),
                          _operand2->Copy() ) 
    }
}

// The expression is: (true and X ) or (Y and (not X) )
BooleanExp * expression; 
Context context;
VariableExp* x = new VariableExp(“X”); 
VariableExp* y = new VariableExp(“Y”);
Expression = new OrExp( 
    new AndExp( new Constant ( true), x),
    new AndExp( y, new NotExp(x) ) );
// 给x和y分别赋值
context.Assign( x, false);
context.Assign( y, true );
// 评估是否符合语法
Bool result = expression->Evaluate( context );

// Now we replace the variable y with a new expression and 
// re-evaluate the expression 
VariableExp* z = new VariableExp(“Z”); 
NotExp not_z (z);
BooleanExp*replacement = expression->Replace(“Y”, not_z);
context.Assign(z, true);
result = replacement->Evaluate ( context );
```

**实施Implementation**

- 应用（vistor pattern）访问者模式来定义解释操作
- 依赖性分析Dependency analysis
  - 例如:如果一个循环中的表达式不依赖于循环中的局部变量，那么它只能被计算一次。
  - 效果缓存：当表达式重要时，先将表达式的值缓存。
  - 并行化
  - 延迟计算:除非显式地请求，否则不计算任何东西。

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621170906351.png" alt="image-20210621170906351" style="zoom:67%;" />



### Lecture 13

#### 补充：类模板特化

**主类模板**（primary class template）、

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621180129865.png" alt="image-20210621180129865" style="zoom:67%;" />

**完全特化的类模板Stack**    （stack<string>s2)

特化了<std::string>

<T>指定为距离类型被称为完全特化

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621180519416.png" alt="image-20210621180519416" style="zoom:67%;" />

部分特化的类模板stack（stack<int *>s3）

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621181533304.png" alt="image-20210621181533304" style="zoom:67%;" />

特化：对类模板更精细的控制，更灵活的选项。

**一般情况：**

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621181937549.png" alt="image-20210621181937549" style="zoom:67%;" />

若能从n个参数中匹配到P1 p2....pk，则可用特化的；P1....Pk非用户指定

c(u1,u2...un) n个参数参考了主类模板形式提供。

**另一个例子**

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621182214499.png" alt="image-20210621182214499" style="zoom:67%;" />

PS：**先与特化比较，全部不同再执行主类模板**

#### 补充1. Traits技术（设计模式）

Traits技术以一个统一的编程接口， 描述各种**数据类型**的基本特征。

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621182534047.png" alt="image-20210621182534047" style="zoom:67%;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621182749371.png" alt="image-20210621182749371" style="zoom:67%;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621183053637.png" alt="image-20210621183053637" style="zoom:67%;" />

#### 补充2. 类型分类（Type Classification)技术

【编译阶段解决】

**目的**

- 设一个模版具有模板参数T，表示 C++中的某种类型。有些情况下，随着 T 所取类型的不同， 该模板会做不同的处理。【获得模板T的具体信息】

- 运算符sizeof 只能够求取一个类型的对象所占用的内存空间 

- dynamic_cast只能施加到一个指针（或引用） 

- typeid返回的信息有限

**问题**：返回baseT、bottomT 

-  int * * ， baseT为 int *， bottomT为 int 

- double * & ， baseT为double *， bottomT为 double 

- typedef int * arrayType[100]， baseT为int *， bottomT为int

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621184304683.png" alt="image-20210621184304683" style="zoom:67%;" />

#### 补充3. CRTP模式（奇异递归模板模式）

:可实现静态多态性，避免虚函数的lating binding开销

父类模板的一个模板参数是子类

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621184526483.png" alt="image-20210621184526483" style="zoom: 50%;" />

- 编译器编译到行①下划线部分时实例化类模板Base。

  它只会将类模板Base中的所有模板参数Derived替换为类子类Derived， 得到一个实例化的类， 检查是否有语法错误， 不会导致编译阶段的“递归调用”。

- 在类模板Base中就可以获得子类的信息， 可以实现static polymorphism， 以避免dynamic polymorphism的小缺点(类树中的每个类都需要定义虚函数； lating binding消耗）

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621184926139.png" alt="image-20210621184926139" style="zoom:67%;" />

**CRTP模式的一个应用：对象地址登记与检查**：

- **背景**

  \- 对象的地址作为一个对象的句柄(标识)（如图中的p）

  \- 一个模块会将该句柄传递给其他模块，也会从外部接收到一个宣称自己为对象句柄的指针

  \- 本模块必须要检查该指针是否为一个合法的指针，然后才能使用

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621185036454.png" alt="image-20210621185036454" style="zoom:67%;" />

**使用CRTP模式**

- 类模板ObjectAddressRegister登记this指针， 需要时执行检查

- 每个派生类对应着一个登记表

- 使用继承使得每个派生类对象**被创建时自动会被登记**

- 模板参数**T使得该类模板能输出派生类的类型信息**(比如名字等) 

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621185348851.png" alt="image-20210621185348851" style="zoom:67%;" />

#### Lecture 14

#### XX17.Observer（观察者）模式——对象行为模式

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621190110507.png" alt="image-20210621190110507" style="zoom:67%;" />
<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621190238438.png" alt="image-20210621190238438" style="zoom:67%;" />

​			将数据和表示分离。

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621190350152.png" alt="image-20210621190350152" style="zoom:67%;" />

关键对象：目标subject<1———多> 观察者observer

**适用性：**

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621190805711.png" alt="image-20210621190805711" style="zoom:67%;" />

**结构：**

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621190922193.png" alt="image-20210621190922193" style="zoom:67%;" />

subject->observer (update)  observer->subject (getstate)

**结果**

- 主体和观察者之间的抽象耦合
  - 主体和观察者可以属于软件系统的不同层次

- 支持广播通信
  - 观察者可以忽略更新消息

**实现：**

1. 一个观察者可以观察多个目标

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621191344049.png" alt="image-20210621191344049" style="zoom:67%;" />

2. 

 - 谁触发了更新

   - subject对象立即触发更新消息

   - 客户端在一系列状态更改后触发更新消息->效率高
 - 改变了什么

     - 推送模型的所有信息都包含在Update方法的参数中

      -  pull模型

-  仅针对您的特定感兴趣事件注册Observer

    ```c++
    void Subject::Attach(Observer*, Aspect & interest)
    // 注册的时候标明对哪个事件感兴趣
	```



**案例sort的需求定义**

- 概述

  对一个文件的所有行进行排序。

- 支持的运行参数

    -i : 忽略大小写

    -n：将关键字看作数字，按照数字大小进行排序

    -f k：关键字从第k个field (field代表用空格分开的token)开始。默认情况为整个一行

    -c k：关键字从第k列开始。默认情况为整个一行

    -p[first|random|median 3] ：指定pivot值

    -r：降序输出，默认情况为升序输出

- 补充说明
  - field的定义为：一行中靠空格、TAB分隔形成若干个field

  - -i和-n同时出现的时候，-n有效

  - -f和-c同时出现的时候，-c有效

  - 如果所指定的field/列数大于一行总的fields的数目/列数，则该行的关键字为空串

**案例sort的设计要求**

- 性能要求

  1. 速度快：需要选择好的排序算法，I/O操作要快

  2. 占用尽量少的内存

- 系统扩展性要求

  不使用STL中的类。

  系统中的类应该具有reusablity（独用性//可重复性）， 细分各个功能，导致多个类，各司其职

- 好像显得小题大做，但是教学中我们不能够使用太大的系统作为案例。因此，在设计每个类的时候，我们要从手头的问题跳出来，使得设计出来的类尽量“**通用**”(不用修改就可以被其他项目使用!)这是理解这个案例的关键

**使用singleton管理运行参数**

- 运行参数格式举例
  - 一般格式：sort[options] 文件名字

  - sort -n -f 4 -p median3 ..\test_files\student_scores.txt
  - sort -f 4 -p median3 ..\test_files\student_scores.txt

- 设计要求

  - 对运行参数进行**集中管理**，而不是使用很多零散的全局变量来管理
  - 只能够有**一个对象来管理**，不能够出现第二个
  - 需要把表示运行参数的数据以及函数**封装**起来

#### 18. Singleton(单件模式)——对象创建型模式

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621192853567.png" alt="image-20210621192853567" style="zoom:67%;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621193108256.png" alt="image-20210621193108256" style="zoom:67%;" />

对一些类来说，只有一个实例是很重要的，比如一个会计系统只能转喻一个公司，许多打印机只能有一个打印假脱机。
比如你有一个线程池子，那你应该保证它只有一个对象，这样的话运行起来快而且不会打架

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621193222920.png" alt="image-20210621193222920" style="zoom:%67;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621193618983.png" alt="image-20210621193618983" style="zoom:80%;" />

```c++
class Options {
 public:
   enum Pivot_Strategy { FIRST, RANDOM, MEDIAN3 };
   static Options * instance( ); // 静态方法
   void parse_args (int argc, char **argv); 
   bool ignore_case( );
   bool key_is_numeric( );
   bool reverse_output( );
   int field_offset ( ); 
   int column_offset ( );
   Pivot_Strategy pivot_strat( );
   char * file_name ( );
 private:
   Options ( );
   bool _ignore_case;
   bool _key_is_numeric;
   bool _reverse_output;
   int _field_offset, _column_offset;
   Pivot_Strategy _pivot_strat;
   char * _file_name;
   
   static Options _instance; // 静态对象
};
```

**类Input的设计**

- 目标

  在内存中形成一个个“行”

- 设计要求
  - I/O要快：不能够使用gets函数一行行读

  - 避免多次的内存分配：只用一次内存分配

- 解决方案

  - 一次内存分配
  - 一次读入
  - 将\n”替换为“\0” (结束符，内存分离成行)

  <img src="D:\Project\面向对象设计\设计模式.assets\image-20210621194426072.png" alt="image-20210621194426072" style="zoom:67%;" />

**应该具有的类**

- 类Input的功能

  - 负责Access_Buffer的分配(但不负责释放)

  - 负责高效地读入数据，形成若干文本行
    ```c++
    class Input {
     public:
        Input();
        char * read (char* file_name); // 读取文件进入buffer
        char * buffer( ) const; // 返回buffer地址
        size_t num_lines() const; // 返回行
     private: 
        size_t _num_lines;
        char * _buffer;
    };
    ```

- 类Array的功能 [ ] 

  - 在运行时候才指定长度的数组 // 动态指定数组

  ```c++
  template <class T>
  class Array {
   public:
      void Resize (size_t size = 0){   // 设置元素个数，设置array
          _size = size; 
          _array = new T [ _size ]; 
      }
      ~Array( ){ delete [ ] _array; };
      T &operator[ ](size_t index){ 
          return _array [index]; // 重载[ ]
      }
      size_t size ( ) const{return _size;}
   private: 
      T * _array;  // 内存块
      size_t _size;
  };
  ```

  

- 类Access_Table的功能 （上面整个图）

  - 构建Access_Table(纯虚函数， 使得该类能通用)
  - 访问Access_Table中的元素
  - 系统结束时候， 释放Access_Buffer

  ```c++
  template <class T>
  class Access_Table {
   public:
      virtual int make_table (char *buffer, size_t num_lines) =0;
      T & element (size_t index){ // 返回index对应的文本行
          return _access_array [ index ];
      }; 
      size_t length( ) const{ return _access_array.size( ); }
  
      virtual ~Access_Table ( ){ delete _access_buffer; }; 
   protected:
   	Array<T> _access_array; 
   	char * _access_buffer; 
  };
  ```
  
  <img src="D:\Project\面向对象设计\设计模式.assets\image-20210621202520767.png" alt="image-20210621202520767" style="zoom:67%;" />
  
  **排序算法设计：快速排序示意**
  
  p[first|random|median 3] ：
  
  <img src="D:\Project\面向对象设计\设计模式.assets\image-20210621195749422.png" alt="image-20210621195749422" style="zoom:67%;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621195819800.png" alt="image-20210621195819800" style="zoom: 67%;" />

<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621195837292.png" alt="image-20210621195837292" style="zoom:67%;" />



<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621200237653.png" alt="image-20210621200237653" style="zoom:67%;" />

```c++
class Pivot_Strategies {
 public:
	virtual int get_pivot( Sort_AT_Adaptor & , int lo, int hi) =0;  // lo下届 hi上届
};
class First_Pivot:public Pivot_Strategies {
 public:
	virtual int get_pivot( Sort_AT_Adaptor & , int lo, int hi);
};
class Random_Pivot:public Pivot_Strategies {
 public:
	Random_Pivot();
	virtual int get_pivot( Sort_AT_Adaptor & , int lo, int hi);
};
class Median3_Pivot:public Pivot_Strategies {
 public:
	virtual int get_pivot( Sort_AT_Adaptor & , int lo, int hi);
};
```

**Adaptor pattern**

​	**---使得Sort能够操作Access_Table**

- 由于Access_Table提供的接口和Sort所期望的接口不同， 所以后者没有办法直接操作它→从AccessTable派生出子类Sort_AT_Adaptor， 提供后者所期望的接口
- 作为一个子类，必须要提供实用的功能了,所以， 需要把Line_Ptrs作为一个模板参数提供给Access_Table。同时， 需要实现虚函数make_table.
- 提供System_Sort所希望的输出流功能。
- <img src="D:\Project\面向对象设计\设计模式.assets\image-20210621202811594.png" alt="image-20210621202811594" style="zoom: 50%;" />

```c++
class Line_Ptrs {
 public:
	// Comparison operator used by sort().
	int operator < (const Line_Ptrs &) const;  // 重构<
	// Beginning of line and key (field or column).
	char *_bol, *_bok; // bol起始位置  bok关键字位置
};

int Line_Ptrs::operator< (const Line_Ptrs & r) const{  // 比较行 关键字、单词、数字
    Compare_Func_Factory::Func_Pointer fp;
    fp = Compare_Func_Factory::instance() ->get_func_pointer();
    return ( (*fp) (this->_bok, r._bok ) <= 0 );
}
```

```c++
// 匹配差异
class Sort_AT_Adaptor: 
 private Access_Table<Line_Ptrs> { //private私有继承  
     
public:
   virtual int make_table (char *buffer, 
                           size_t num_lines); 
     Line_Ptrs &operator[ ] (size_t index){
         return element(index);
     }
     size_t size ( ) const{
         return length();
     }
     // 提供System_Sort所希望的输出流功能。
     friend std::ostream & operator<< ( std::ostream & os, 
                                       Sort_AT_Adaptor & sort_at_adaptor );
 };
```

```c++
class Compare_Func_Factory{
public:
    typedef int (*Func_Pointer) (const char*, 
                                 const char*);
    static Compare_Func_Factory * instance( );
    void set_func_pointer( );
    Func_Pointer get_func_pointer();
private:
    Compare_Func_Factory ( );
    static Compare_Func_Factory _instance;
    Func_Pointer _func_pointer;
};
```



<img src="D:\Project\面向对象设计\设计模式.assets\image-20210621202926795.png" alt="image-20210621202926795" style="zoom:50%;" />

**所使用的设计模式总结**

- Singleton
  - Options， System_Sort， Compare_Func_Factory

- Strategies
  - Pivot_Strategies以及其三个子类

- Adaptor
  - Sort_AT_Adaptor

- Facade
  - System_Sort
